Let's try this yet again...

Let's consider something that could/would/should make use of types.

Let's use a ValueValidator for example.

It could make use of types in two or three ways.

It has data that it receives to its constructor. I'll call this the validator instance data.

It has data useful in metaprogramming exposed on its class shared by all instances.
I'll call this the validator class metadata.

Also, it can return an error which has a symbol and a context schema
The context schema can be thought of as a type. So we should call this a context type.

Why not also have a value type??

```ruby
class MinValidator
  class ErrorClass < Error
    class << self 
      def context_type
        type_registry.for(
          attribute_name: :symbol,
          value: :duck
        )
      end
    end
  end
  
  class << self
    def error_context_type
      ErrorClass.context_type
    end
    
    def data_type
      type_registry.for(:integer)
    end
    
    def value_type
      type_registry.for(:integer) # Should we support unioning tpyes? Then these could support
      # multiple types
    end
  end
  
  attr_accessor :data 
  
  def initialize(data)
    self.data = data
  end
  
  delegate :error_context_type, :data_type, to: :class
  
  def min
    data
  end
  
  def validation_errors(int)
    if int < min
      build_error
    end
  end
  
  # should we relocate things like the message to the error class?
  def build_error(value, message: error_message(value), context: error_context(value))
    error_class.new(
      message:,
      context:,
    )
  end
end
```

TODO: Something missing here is the desugarize and schema validation concerns that come with the validator...

So here we can ask the validator or in this case even its class for three types:

1) the type of the context of the error it might return
2) the type of the data used to construct the validator
3) the type of the value expected by the validate_errors method

These types can be used to cast/transform/validate (process) any of these values at the
appropriate times but also can be used for metaprogramming such as building type-aware tools
(such as TypeScript remote commands, for example.)

What else can types do?

Types house their supported validators/transformers/processors/casters. That is, they act as a value processor registry, 
as well as acting like a value processor themselves.

They could be used as "base" types when constructing other types.

Take for example specifying command inputs...

```ruby
class Whatever < Command
  input_schema foo: :integer,
               bar: [:integer, :optional, :allow_blank, min: 1]
end
```

Here we are specifying a new type which is an attributes type which has
one attribute of an existing type and one attribute of yet another new type.

foo's type is found as type registered on a type registry.
bar's type is generated by finding the :integer type in the type registry and using
it as a base type of a newly constructed type which allows blank and has a min
of 1 validation applied.

the input type is generated by finding the :attributes type in the registry and
using it as the base type for constructing the new type.

So how does TypeRegistry#for work??

1) it can accept one of the following and returns a type:
   1) A type identifier
      2) checked for hits locally and then in any fallback registries
      3) Could be various things, such as :integer or Integer
   4) A strict type schema/declaration/description
      5) This would construct a new type by passing this information to a class
         that knows how to build types programmatically based on the given declaration
      6) This could be a sugary declaration that can be converted into a strict declaration
   7) An instance of a type
      8) Just returns what is passed in unmodified

So attempting this, for the millionth time... here are the concepts defined...
